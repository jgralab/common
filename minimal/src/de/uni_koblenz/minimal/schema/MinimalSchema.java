/*
 * This code was generated automatically.
 * Do NOT edit this file, changes will be lost.
 * Instead, change and commit the underlying schema.
 */

package de.uni_koblenz.minimal.schema;

import de.uni_koblenz.jgralab.Graph;
import de.uni_koblenz.jgralab.GraphIO;
import de.uni_koblenz.jgralab.GraphIOException;
import de.uni_koblenz.jgralab.ProgressFunction;

import de.uni_koblenz.jgralab.schema.impl.SchemaImpl;

import de.uni_koblenz.jgralab.schema.EdgeClass;
import de.uni_koblenz.jgralab.schema.GraphClass;
import de.uni_koblenz.jgralab.schema.VertexClass;

import de.uni_koblenz.minimal.schema.MinimalSchemaFactory;

import java.lang.ref.WeakReference;

/**
 * The schema MinimalSchema is implemented following the singleton pattern.
 * To get the instance, use the static method <code>instance()</code>.
 */
public class MinimalSchema extends SchemaImpl {
	public final GraphClass gc_MinimalGraph;
	public final VertexClass vc_Node;
	public final EdgeClass ec_Link;

	/**
	 * the weak reference to the singleton instance
	 */
	static WeakReference<MinimalSchema> theInstance = new WeakReference<MinimalSchema>(null);
	
	/**
	 * @return the singleton instance of MinimalSchema
	 */
	public static MinimalSchema instance() {
		MinimalSchema s = theInstance.get();
		if (s != null) {
			return s;
		}
		synchronized (MinimalSchema.class) {
			s = theInstance.get();
			if (s != null) {
				return s;
			}
			s = new MinimalSchema();
			theInstance = new WeakReference<MinimalSchema>(s);
		}
		return s;
	}
	
	/**
	 * Creates a MinimalSchema and builds its schema classes.
	 * This constructor is private. Use the <code>instance()</code> method
	 * to acess the schema.
	 */
	private MinimalSchema() {
		super("MinimalSchema", "de.uni_koblenz.minimal.schema");

		{
			GraphClass gc = gc_MinimalGraph = createGraphClass("MinimalGraph");
			gc.setAbstract(false);
			@SuppressWarnings("unused")
			VertexClass vc_Vertex = getDefaultVertexClass();

			{
				VertexClass vc = vc_Node = gc.createVertexClass("Node");
				vc.setAbstract(false);
				vc.addAttribute(createAttribute("label", getDomain("String"), getAttributedElementClass("Node"), null));
			}

			{
				EdgeClass ec = ec_Link = gc.createEdgeClass("Link",
					vc_Node, 0, 2147483647, "source", de.uni_koblenz.jgralab.schema.AggregationKind.NONE,
					vc_Node, 0, 2147483647, "target", de.uni_koblenz.jgralab.schema.AggregationKind.NONE);
				ec.setAbstract(false);
			}

		}

		graphFactory = new MinimalSchemaFactory();

	}

	/**
	 * Creates a new MinimalGraph graph with initial vertex and edge counts <code>vMax</code>, <code>eMax</code>.
	 *
	 * @param vMax initial vertex count
	 * @param eMax initial edge count
	*/
	public MinimalGraph createMinimalGraph(int vMax, int eMax) {
		return (MinimalGraph) graphFactory.createGraph(MinimalGraph.class, null, vMax, eMax);
	}
	
	/**
	 * Creates a new MinimalGraph graph with the ID <code>id</code> initial vertex and edge counts <code>vMax</code>, <code>eMax</code>.
	 *
	 * @param id the id name of the new graph
	 * @param vMax initial vertex count
	 * @param eMax initial edge count
	 */
	public MinimalGraph createMinimalGraph(String id, int vMax, int eMax) {
		return (MinimalGraph) graphFactory.createGraph(MinimalGraph.class, id, vMax, eMax);
	}
	
	/**
	 * Creates a new MinimalGraph graph.
	*/
	public MinimalGraph createMinimalGraph() {
		return (MinimalGraph) graphFactory.createGraph(MinimalGraph.class, null);
	}
	
	/**
	 * Creates a new MinimalGraph graph with the ID <code>id</code>.
	 *
	 * @param id the id name of the new graph
	 */
	public MinimalGraph createMinimalGraph(String id) {
		return (MinimalGraph) graphFactory.createGraph(MinimalGraph.class, id);
	}
	
	/**
	 * Creates a new MinimalGraph graph with transaction support with initial vertex and edge counts <code>vMax</code>, <code>eMax</code>.
	 *
	 * @param vMax initial vertex count
	 * @param eMax initial edge count
	*/
	public MinimalGraph createMinimalGraphWithTransactionSupport(int vMax, int eMax) {
		throw new UnsupportedOperationException("No Transaction support compiled.");
	}
	
	/**
	 * Creates a new MinimalGraph graph with transaction support with the ID <code>id</code> initial vertex and edge counts <code>vMax</code>, <code>eMax</code>.
	 *
	 * @param id the id name of the new graph
	 * @param vMax initial vertex count
	 * @param eMax initial edge count
	 */
	public MinimalGraph createMinimalGraphWithTransactionSupport(String id, int vMax, int eMax) {
		throw new UnsupportedOperationException("No Transaction support compiled.");
	}
	
	/**
	 * Creates a new MinimalGraph graph.
	*/
	public MinimalGraph createMinimalGraphWithTransactionSupport() {
		throw new UnsupportedOperationException("No Transaction support compiled.");
	}
	
	/**
	 * Creates a new MinimalGraph graph with the ID <code>id</code>.
	 *
	 * @param id the id name of the new graph
	 */
	public MinimalGraph createMinimalGraphWithTransactionSupport(String id) {
		throw new UnsupportedOperationException("No Transaction support compiled.");
	}
	
	/**
	 * Loads a MinimalGraph graph from the file <code>filename</code>.
	 *
	 * @param filename the name of the file
	 * @return the loaded MinimalGraph
	 * @throws GraphIOException if the graph cannot be loaded
	 */
	public MinimalGraph loadMinimalGraph(String filename) throws GraphIOException {
		return loadMinimalGraph(filename, null);
	}
	
	/**
	 * Loads a MinimalGraph graph from the file <code>filename</code>.
	 *
	 * @param filename the name of the file
	 * @param pf a progress function to monitor graph loading
	 * @return the loaded MinimalGraph
	 * @throws GraphIOException if the graph cannot be loaded
	 */
	public MinimalGraph loadMinimalGraph(String filename, ProgressFunction pf) throws GraphIOException {
		Graph graph = GraphIO.loadGraphFromFile(filename, this, pf);
	if (!(graph instanceof MinimalGraph)) {
		throw new GraphIOException("Graph in file '" + filename + "' is not an instance of GraphClass MinimalGraph");
	}	return (MinimalGraph) graph;

	}
	
	/**
	 * Saves a MinimalGraph graph to the file <code>filename</code>.
	 *
	 * @param MinimalGraph the graph to save
	 * @param filename the name of the file
	 * @throws GraphIOException if the graph cannot be saved
	 */
	
	public void saveMinimalGraph(String filename, MinimalGraph MinimalGraph) throws GraphIOException {
		saveMinimalGraph(filename, MinimalGraph, null);
	}
	/**
	 * Saves a MinimalGraph graph to the file <code>filename</code>.
	 *
	 * @param MinimalGraph the graph to save
	 * @param filename the name of the file
	 * @param pf a progress function to monitor graph loading
	 * @throws GraphIOException if the graph cannot be saved
	 */
	
	public void saveMinimalGraph(String filename, MinimalGraph MinimalGraph, ProgressFunction pf) throws GraphIOException {
		GraphIO.saveGraphToFile(filename, MinimalGraph, pf);
	}
	
	/**
	 * Loads a MinimalGraph graph with transaction support from the file <code>filename</code>.
	 *
	 * @param filename the name of the file
	 * @return the loaded MinimalGraph
	 * @throws GraphIOException if the graph cannot be loaded
	 */
	public MinimalGraph loadMinimalGraphWithTransactionSupport(String filename) throws GraphIOException {
		throw new UnsupportedOperationException("No Transaction support compiled.");
	}
	
	/**
	 * Loads a MinimalGraph graph with transaction support from the file <code>filename</code>.
	 *
	 * @param filename the name of the file
	 * @param pf a progress function to monitor graph loading
	 * @return the loaded MinimalGraph
	 * @throws GraphIOException if the graph cannot be loaded
	 */
	public MinimalGraph loadMinimalGraphWithTransactionSupport(String filename, ProgressFunction pf) throws GraphIOException {
		throw new UnsupportedOperationException("No Transaction support compiled.");
	}
	
	@Override
	public boolean equals(Object o) {
		return super.equals(o);
	}
	
	@Override
	public int hashCode() {
		return super.hashCode();
	}
}
